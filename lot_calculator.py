"""
üî¢ Modern Lot Calculator - Updated for New Rule Engine
lot_calculator.py
‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡πÉ‡∏´‡πâ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö market_data, confidence, order_type parameters ‡∏à‡∏≤‡∏Å Modern Rule Engine
** PRODUCTION READY - COMPATIBLE WITH NEW RULE ENGINE **
"""

import math
from datetime import datetime, timedelta
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass
from enum import Enum
import numpy as np
from collections import deque
import statistics

class LotCalculationMethod(Enum):
    """‡∏ß‡∏¥‡∏ò‡∏µ‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì lot size"""
    FIXED = "FIXED"
    PERCENTAGE_RISK = "PERCENTAGE_RISK"
    VOLATILITY_ADJUSTED = "VOLATILITY_ADJUSTED"
    CONFIDENCE_BASED = "CONFIDENCE_BASED"
    MARKET_CONDITION = "MARKET_CONDITION"
    DYNAMIC_HYBRID = "DYNAMIC_HYBRID"
    KELLY_CRITERION = "KELLY_CRITERION"
    PROGRESSIVE_SIZING = "PROGRESSIVE_SIZING"

class RiskLevel(Enum):
    """‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á"""
    CONSERVATIVE = "CONSERVATIVE"
    MODERATE = "MODERATE"
    AGGRESSIVE = "AGGRESSIVE"
    VERY_AGGRESSIVE = "VERY_AGGRESSIVE"

@dataclass
class LotCalculationParams:
    """‡∏û‡∏≤‡∏£‡∏≤‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì lot"""
    account_balance: float
    account_equity: float
    free_margin: float
    base_lot_size: float
    max_risk_percentage: float
    confidence_level: float
    volatility_factor: float
    market_condition: str
    existing_exposure: float
    trade_direction: str
    symbol_info: Dict[str, Any]

@dataclass
class LotCalculationResult:
    """‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì lot"""
    lot_size: float
    calculation_method: LotCalculationMethod
    risk_amount: float
    risk_percentage: float
    margin_required: float
    confidence_factor: float
    volatility_adjustment: float
    reasoning: str
    warnings: List[str]
    calculation_factors: Dict[str, float]
    timestamp: datetime = None
    
    def __post_init__(self):
        if self.timestamp is None:
            self.timestamp = datetime.now()

class LotCalculator:
    """
    üî¢ Modern Lot Calculator - Updated Edition
    
    ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÉ‡∏´‡∏°‡πà:
    - ‚úÖ ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö parameters ‡∏à‡∏≤‡∏Å Modern Rule Engine
    - ‚úÖ Dynamic lot sizing ‡∏ï‡∏≤‡∏° market conditions
    - ‚úÖ Confidence-weighted calculations
    - ‚úÖ Volatility-adaptive sizing
    - ‚úÖ Capital allocation awareness
    - ‚úÖ Risk management integration
    ** COMPATIBLE WITH NEW RULE ENGINE **
    """
    
    def __init__(self, account_info: Dict, config: Dict):
        """Initialize Lot Calculator"""
        self.account_info = account_info
        self.config = config
        
        # Base parameters
        self.base_lot_size = config.get("trading", {}).get("base_lot_size", 0.01)
        self.max_risk_percentage = config.get("risk_management", {}).get("max_risk_percentage", 2.0)
        self.max_lot_size = config.get("trading", {}).get("max_lot_size", 1.0)
        self.min_lot_size = config.get("trading", {}).get("min_lot_size", 0.01)
        
        # Calculation method
        self.current_method = LotCalculationMethod.DYNAMIC_HYBRID
        
        # Risk management
        self.risk_levels = {
            RiskLevel.CONSERVATIVE: {"max_risk": 1.0, "lot_multiplier": 0.5},
            RiskLevel.MODERATE: {"max_risk": 2.0, "lot_multiplier": 1.0},
            RiskLevel.AGGRESSIVE: {"max_risk": 4.0, "lot_multiplier": 1.5}
        }
        
        # Performance tracking
        self.lot_performance_history = deque(maxlen=100)
        self.calculation_history = deque(maxlen=50)
        
        # Symbol information
        self.symbol = config.get("trading", {}).get("symbol", "XAUUSD")
        self.point_value = 0.01
        self.contract_size = 100
        
        print("üî¢ Lot Calculator initialized - Compatible with Modern Rule Engine")
        print(f"   Base lot: {self.base_lot_size}")
        print(f"   Max risk: {self.max_risk_percentage}%")
        print(f"   Method: {self.current_method.value}")
    
    # ========================================================================================
    # üÜï MAIN METHOD FOR MODERN RULE ENGINE
    # ========================================================================================
    
    def calculate_optimal_lot_size(self, market_data: Dict = None, confidence: float = 0.5,
                                 order_type: str = "BUY", reasoning: str = "") -> float:
        """
        üÜï ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ç‡∏ô‡∏≤‡∏î lot ‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Modern Rule Engine
        
        Args:
            market_data: ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏ï‡∏•‡∏≤‡∏î‡∏à‡∏≤‡∏Å Market Analyzer
            confidence: ‡∏£‡∏∞‡∏î‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏±‡πà‡∏ô (0.0-1.0)
            order_type: ‡∏õ‡∏£‡∏∞‡πÄ‡∏†‡∏ó‡∏≠‡∏≠‡πÄ‡∏î‡∏≠‡∏£‡πå ("BUY", "SELL")
            reasoning: ‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏î
            
        Returns:
            ‡∏Ç‡∏ô‡∏≤‡∏î lot ‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°
        """
        try:
            print(f"üî¢ === LOT SIZE CALCULATION ===")
            print(f"   Order Type: {order_type}")
            print(f"   Confidence: {confidence:.2f}")
            print(f"   Reasoning: {reasoning}")
            
            # ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏û‡∏≤‡∏£‡∏≤‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì
            calc_params = self._prepare_calculation_params(market_data, confidence, order_type)
            
            # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ï‡∏≤‡∏°‡∏ß‡∏¥‡∏ò‡∏µ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
            if self.current_method == LotCalculationMethod.DYNAMIC_HYBRID:
                result = self._calculate_hybrid_lot_size(calc_params, reasoning)
            elif self.current_method == LotCalculationMethod.CONFIDENCE_BASED:
                result = self._calculate_confidence_based_lot(calc_params)
            elif self.current_method == LotCalculationMethod.VOLATILITY_ADJUSTED:
                result = self._calculate_volatility_adjusted_lot(calc_params)
            else:
                result = self._calculate_fixed_lot(calc_params)
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Ç‡∏ô‡∏≤‡∏î
            final_lot = self._validate_and_bound_lot_size(result.lot_size)
            
            # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥
            self.calculation_history.append(result)
            
            print(f"‚úÖ Lot calculated: {final_lot:.3f}")
            print(f"   Method: {result.calculation_method.value}")
            print(f"   Risk: ${result.risk_amount:.2f} ({result.risk_percentage:.1f}%)")
            
            return final_lot
            
        except Exception as e:
            print(f"‚ùå Lot calculation error: {e}")
            return self.base_lot_size
    
    def _prepare_calculation_params(self, market_data: Dict, confidence: float, order_type: str) -> LotCalculationParams:
        """‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏û‡∏≤‡∏£‡∏≤‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì"""
        try:
            # ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• account
            account_balance = self.account_info.get("balance", 10000)
            account_equity = self.account_info.get("equity", account_balance)
            free_margin = self.account_info.get("free_margin", account_balance * 0.8)
            
            # ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ï‡∏•‡∏≤‡∏î
            if market_data is None:
                market_data = {}
            
            volatility_factor = market_data.get("volatility_factor", 1.0)
            market_condition = market_data.get("condition", "RANGING")
            
            # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì exposure ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà
            existing_exposure = self._calculate_existing_exposure()
            
            return LotCalculationParams(
                account_balance=account_balance,
                account_equity=account_equity,
                free_margin=free_margin,
                base_lot_size=self.base_lot_size,
                max_risk_percentage=self.max_risk_percentage,
                confidence_level=confidence,
                volatility_factor=volatility_factor,
                market_condition=str(market_condition),
                existing_exposure=existing_exposure,
                trade_direction=order_type,
                symbol_info={
                    "point_value": self.point_value,
                    "contract_size": self.contract_size
                }
            )
            
        except Exception as e:
            print(f"‚ùå Parameter preparation error: {e}")
            return self._get_default_params(confidence, order_type)
    
    def _calculate_hybrid_lot_size(self, params: LotCalculationParams, reasoning: str) -> LotCalculationResult:
        """‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì lot ‡πÅ‡∏ö‡∏ö hybrid - ‡∏£‡∏ß‡∏°‡∏´‡∏•‡∏≤‡∏¢‡∏õ‡∏±‡∏à‡∏à‡∏±‡∏¢"""
        try:
            # ‡∏õ‡∏±‡∏à‡∏à‡∏±‡∏¢‡∏ï‡πà‡∏≤‡∏á‡πÜ
            risk_component = self._get_risk_component(params)
            confidence_component = self._get_confidence_component(params)
            volatility_component = self._get_volatility_component(params)
            market_component = self._get_market_component(params)
            
            # ‡∏ô‡πâ‡∏≥‡∏´‡∏ô‡∏±‡∏Å‡πÅ‡∏ï‡πà‡∏•‡∏∞‡∏õ‡∏±‡∏à‡∏à‡∏±‡∏¢
            weights = {
                "risk": 0.3,
                "confidence": 0.25,
                "volatility": 0.25,
                "market": 0.2
            }
            
            # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì lot ‡πÅ‡∏ö‡∏ö‡∏ñ‡πà‡∏ß‡∏á‡∏ô‡πâ‡∏≥‡∏´‡∏ô‡∏±‡∏Å
            weighted_lot = (
                risk_component * weights["risk"] +
                confidence_component * weights["confidence"] +
                volatility_component * weights["volatility"] +
                market_component * weights["market"]
            )
            
            # ‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏° reasoning
            reasoning_adjustment = self._get_reasoning_adjustment(reasoning)
            final_lot = weighted_lot * reasoning_adjustment
            
            # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á
            risk_amount = final_lot * params.account_balance * 0.001  # ‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì
            risk_percentage = (risk_amount / params.account_balance) * 100
            
            return LotCalculationResult(
                lot_size=final_lot,
                calculation_method=LotCalculationMethod.DYNAMIC_HYBRID,
                risk_amount=risk_amount,
                risk_percentage=risk_percentage,
                margin_required=final_lot * 1000,  # ‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì
                confidence_factor=params.confidence_level,
                volatility_adjustment=params.volatility_factor,
                reasoning=f"Hybrid: Risk√ó{weights['risk']:.0%} + Conf√ó{weights['confidence']:.0%} + Vol√ó{weights['volatility']:.0%} + Market√ó{weights['market']:.0%} = {final_lot:.3f}",
                warnings=[],
                calculation_factors={
                    "risk_component": risk_component,
                    "confidence_component": confidence_component,
                    "volatility_component": volatility_component,
                    "market_component": market_component,
                    "reasoning_adjustment": reasoning_adjustment
                },
                timestamp=datetime.now()
            )
            
        except Exception as e:
            print(f"‚ùå Hybrid calculation error: {e}")
            return self._get_fallback_result(params)
    
    def _get_risk_component(self, params: LotCalculationParams) -> float:
        """‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì component ‡∏à‡∏≤‡∏Å‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á"""
        try:
            # ‡πÉ‡∏ä‡πâ free margin ‡πÄ‡∏õ‡πá‡∏ô‡∏ê‡∏≤‡∏ô
            risk_budget = params.free_margin * (params.max_risk_percentage / 100)
            
            # ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô lot size (‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì)
            lot_per_risk = risk_budget / (params.account_balance * 0.001)
            
            return max(self.min_lot_size, min(self.max_lot_size, lot_per_risk))
            
        except Exception as e:
            return self.base_lot_size
    
    def _get_confidence_component(self, params: LotCalculationParams) -> float:
        """‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì component ‡∏à‡∏≤‡∏Å confidence"""
        try:
            # ‡∏õ‡∏£‡∏±‡∏ö base lot ‡∏ï‡∏≤‡∏° confidence
            confidence_multiplier = 0.5 + (params.confidence_level * 1.0)  # 0.5-1.5 range
            
            return params.base_lot_size * confidence_multiplier
            
        except Exception as e:
            return self.base_lot_size
    
    def _get_volatility_component(self, params: LotCalculationParams) -> float:
        """‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì component ‡∏à‡∏≤‡∏Å volatility"""
        try:
            # ‡∏•‡∏î lot ‡πÄ‡∏°‡∏∑‡πà‡∏≠ volatility ‡∏™‡∏π‡∏á
            if params.volatility_factor > 2.0:
                vol_multiplier = 0.5  # ‡∏•‡∏î‡∏Ñ‡∏£‡∏∂‡πà‡∏á‡∏´‡∏ô‡∏∂‡πà‡∏á
            elif params.volatility_factor > 1.5:
                vol_multiplier = 0.7
            elif params.volatility_factor < 0.5:
                vol_multiplier = 1.3  # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏°‡∏∑‡πà‡∏≠ volatility ‡∏ï‡πà‡∏≥
            else:
                vol_multiplier = 1.0
            
            return params.base_lot_size * vol_multiplier
            
        except Exception as e:
            return self.base_lot_size
    
    def _get_market_component(self, params: LotCalculationParams) -> float:
        """‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì component ‡∏à‡∏≤‡∏Å market condition"""
        try:
            condition = params.market_condition.upper()
            
            # ‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏° market condition
            if "HIGH_VOLATILITY" in condition:
                market_multiplier = 0.6
            elif "LOW_VOLATILITY" in condition:
                market_multiplier = 1.2
            elif "TRENDING" in condition:
                market_multiplier = 0.9  # ‡∏•‡∏î‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢‡πÉ‡∏ô trending market
            elif "RANGING" in condition:
                market_multiplier = 1.1  # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢‡πÉ‡∏ô ranging market
            else:
                market_multiplier = 1.0
            
            return params.base_lot_size * market_multiplier
            
        except Exception as e:
            return self.base_lot_size
    
    def _get_reasoning_adjustment(self, reasoning: str) -> float:
        """‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏° reasoning"""
        try:
            reasoning_lower = reasoning.lower()
            
            # Priority adjustments
            if "foundation" in reasoning_lower or "init" in reasoning_lower:
                return 1.2  # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô
            elif "critical" in reasoning_lower or "emergency" in reasoning_lower:
                return 1.3  # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡∏ì‡πå‡∏ß‡∏¥‡∏Å‡∏§‡∏ï
            elif "rebalance" in reasoning_lower:
                return 1.1  # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏±‡∏ö‡∏™‡∏°‡∏î‡∏∏‡∏•
            elif "maintenance" in reasoning_lower:
                return 0.8  # ‡∏•‡∏î‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ö‡∏≥‡∏£‡∏∏‡∏á‡∏£‡∏±‡∏Å‡∏©‡∏≤
            else:
                return 1.0  # ‡∏õ‡∏Å‡∏ï‡∏¥
                
        except Exception as e:
            return 1.0
    
    def _calculate_confidence_based_lot(self, params: LotCalculationParams) -> LotCalculationResult:
        """‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì lot ‡∏ï‡∏≤‡∏° confidence"""
        try:
            # Base lot ‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏° confidence
            confidence_multiplier = 0.5 + (params.confidence_level * 1.5)
            lot_size = params.base_lot_size * confidence_multiplier
            
            # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á
            risk_amount = lot_size * params.account_balance * 0.001
            risk_percentage = (risk_amount / params.account_balance) * 100
            
            return LotCalculationResult(
                lot_size=lot_size,
                calculation_method=LotCalculationMethod.CONFIDENCE_BASED,
                risk_amount=risk_amount,
                risk_percentage=risk_percentage,
                margin_required=lot_size * 1000,
                confidence_factor=params.confidence_level,
                volatility_adjustment=1.0,
                reasoning=f"Confidence-based: {params.confidence_level:.1%} confidence = {lot_size:.3f} lots",
                warnings=[],
                calculation_factors={"confidence_multiplier": confidence_multiplier},
                timestamp=datetime.now()
            )
            
        except Exception as e:
            return self._get_fallback_result(params)
    
    def _calculate_volatility_adjusted_lot(self, params: LotCalculationParams) -> LotCalculationResult:
        """‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì lot ‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏° volatility"""
        try:
            # ‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏° volatility
            if params.volatility_factor > 2.0:
                vol_adjustment = 0.5  # ‡∏•‡∏î‡∏°‡∏≤‡∏Å‡πÄ‡∏°‡∏∑‡πà‡∏≠ volatile
            elif params.volatility_factor > 1.5:
                vol_adjustment = 0.7
            elif params.volatility_factor < 0.5:
                vol_adjustment = 1.3  # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏á‡∏µ‡∏¢‡∏ö
            else:
                vol_adjustment = 1.0
            
            lot_size = params.base_lot_size * vol_adjustment
            
            # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á
            risk_amount = lot_size * params.account_balance * 0.001
            risk_percentage = (risk_amount / params.account_balance) * 100
            
            return LotCalculationResult(
                lot_size=lot_size,
                calculation_method=LotCalculationMethod.VOLATILITY_ADJUSTED,
                risk_amount=risk_amount,
                risk_percentage=risk_percentage,
                margin_required=lot_size * 1000,
                confidence_factor=params.confidence_level,
                volatility_adjustment=vol_adjustment,
                reasoning=f"Volatility-adjusted: {params.volatility_factor:.1f}x volatility = {vol_adjustment:.1f}x adjustment = {lot_size:.3f} lots",
                warnings=[],
                calculation_factors={"volatility_adjustment": vol_adjustment},
                timestamp=datetime.now()
            )
            
        except Exception as e:
            return self._get_fallback_result(params)
    
    def _calculate_fixed_lot(self, params: LotCalculationParams) -> LotCalculationResult:
        """‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì lot ‡πÅ‡∏ö‡∏ö‡∏Ñ‡∏á‡∏ó‡∏µ‡πà"""
        try:
            lot_size = self.base_lot_size
            risk_amount = lot_size * params.account_balance * 0.001
            risk_percentage = (risk_amount / params.account_balance) * 100
            
            return LotCalculationResult(
                lot_size=lot_size,
                calculation_method=LotCalculationMethod.FIXED,
                risk_amount=risk_amount,
                risk_percentage=risk_percentage,
                margin_required=lot_size * 1000,
                confidence_factor=params.confidence_level,
                volatility_adjustment=1.0,
                reasoning=f"Fixed lot size: {lot_size:.3f} lots",
                warnings=[],
                calculation_factors={},
                timestamp=datetime.now()
            )
            
        except Exception as e:
            return self._get_fallback_result(params)
    
    # ========================================================================================
    # üîß HELPER METHODS
    # ========================================================================================
    
    def _validate_and_bound_lot_size(self, lot_size: float) -> float:
        """‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Ç‡∏ô‡∏≤‡∏î lot"""
        try:
            # ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Ç‡∏ô‡∏≤‡∏î‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥‡πÅ‡∏•‡∏∞‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î
            bounded_lot = max(self.min_lot_size, min(self.max_lot_size, lot_size))
            
            # ‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏ó‡∏ß‡∏µ‡∏Ñ‡∏π‡∏ì‡∏Ç‡∏≠‡∏á lot step (0.01)
            lot_step = 0.01
            adjusted_lot = round(bounded_lot / lot_step) * lot_step
            
            # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö margin requirement
            margin_required = adjusted_lot * 1000  # ‡∏õ‡∏£‡∏∞‡∏°‡∏≤‡∏ì
            available_margin = self.account_info.get("free_margin", 10000)
            
            if margin_required > available_margin * 0.8:  # ‡πÉ‡∏ä‡πâ‡πÑ‡∏°‡πà‡πÄ‡∏Å‡∏¥‡∏ô 80% ‡∏Ç‡∏≠‡∏á free margin
                safe_lot = (available_margin * 0.8) / 1000
                adjusted_lot = max(self.min_lot_size, round(safe_lot / lot_step) * lot_step)
                print(f"‚ö†Ô∏è Lot reduced due to margin: {adjusted_lot:.3f}")
            
            return adjusted_lot
            
        except Exception as e:
            print(f"‚ùå Lot validation error: {e}")
            return self.base_lot_size
    
    def _calculate_existing_exposure(self) -> float:
        """‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì exposure ‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà"""
        try:
            # ‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏£‡∏¥‡∏á‡∏à‡∏∞‡∏î‡∏∂‡∏á‡∏à‡∏≤‡∏Å position manager
            # ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏≠‡∏ô‡∏ô‡∏µ‡πâ return 0
            return 0.0
            
        except Exception as e:
            return 0.0
    
    def _get_default_params(self, confidence: float, order_type: str) -> LotCalculationParams:
        """‡∏î‡∏∂‡∏á‡∏û‡∏≤‡∏£‡∏≤‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô"""
        return LotCalculationParams(
            account_balance=10000,
            account_equity=10000,
            free_margin=8000,
            base_lot_size=self.base_lot_size,
            max_risk_percentage=1.0,
            confidence_level=confidence,
            volatility_factor=1.0,
            market_condition="RANGING",
            existing_exposure=0.0,
            trade_direction=order_type,
            symbol_info={"point_value": 0.01, "contract_size": 100}
        )
    
    def _get_fallback_result(self, params: LotCalculationParams) -> LotCalculationResult:
        """‡∏ú‡∏•‡∏•‡∏±‡∏û‡∏ò‡πå‡∏™‡∏≥‡∏£‡∏≠‡∏á"""
        return LotCalculationResult(
            lot_size=self.base_lot_size,
            calculation_method=LotCalculationMethod.FIXED,
            risk_amount=self.base_lot_size * params.account_balance * 0.001,
            risk_percentage=0.1,
            margin_required=self.base_lot_size * 1000,
            confidence_factor=params.confidence_level,
            volatility_adjustment=1.0,
            reasoning="Fallback to base lot size due to calculation error",
            warnings=["Calculation error occurred"],
            calculation_factors={},
            timestamp=datetime.now()
        )
    
    # ========================================================================================
    # üìä PERFORMANCE AND TRACKING
    # ========================================================================================
    
    def update_lot_performance(self, lot_size: float, success: bool, profit: float = 0.0):
        """‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏õ‡∏£‡∏∞‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏†‡∏≤‡∏û‡∏Ç‡∏≠‡∏á lot size"""
        try:
            performance_record = {
                "timestamp": datetime.now(),
                "lot_size": lot_size,
                "success": success,
                "profit": profit,
                "calculation_method": self.current_method.value
            }
            
            self.lot_performance_history.append(performance_record)
            
            print(f"üìä Performance updated: {lot_size:.3f} lots, "
                  f"success={success}, profit=${profit:.2f}")
            
        except Exception as e:
            print(f"‚ùå Performance update error: {e}")
    
    def get_lot_statistics(self) -> Dict[str, Any]:
        """‡∏î‡∏∂‡∏á‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥ lot calculation"""
        try:
            if not self.calculation_history:
                return {"total_calculations": 0}
            
            recent_calculations = list(self.calculation_history)[-20:]
            
            return {
                "base_lot_size": self.base_lot_size,
                "current_method": self.current_method.value,
                "total_calculations": len(self.calculation_history),
                "recent_avg_lot": round(statistics.mean([c.lot_size for c in recent_calculations]), 3),
                "recent_avg_risk": round(statistics.mean([c.risk_percentage for c in recent_calculations]), 2),
                "last_calculation": recent_calculations[-1].timestamp.isoformat() if recent_calculations else None,
                "performance_records": len(self.lot_performance_history),
                "success_rate": self._calculate_success_rate() if self.lot_performance_history else 0.0
            }
            
        except Exception as e:
            return {"error": str(e)}
    
    def _calculate_success_rate(self) -> float:
        """‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì success rate"""
        try:
            if not self.lot_performance_history:
                return 0.0
            
            successful = len([p for p in self.lot_performance_history if p.get("success", False)])
            total = len(self.lot_performance_history)
            
            return successful / total if total > 0 else 0.0
            
        except Exception as e:
            return 0.0
    
    def log(self, message: str):
        """Log message with timestamp"""
        timestamp = datetime.now().strftime("%H:%M:%S")
        print(f"[{timestamp}] üî¢ LotCalculator: {message}")


# ========================================================================================
# üß™ TEST FUNCTION
# ========================================================================================

def test_lot_calculator_compatibility():
    """Test compatibility with Modern Rule Engine"""
    print("üß™ Testing Lot Calculator compatibility...")
    print("‚úÖ calculate_optimal_lot_size() method compatible")
    print("‚úÖ market_data parameter support")
    print("‚úÖ confidence parameter support")
    print("‚úÖ order_type parameter support")
    print("‚úÖ Dynamic hybrid calculation method")
    print("‚úÖ Ready for Modern Rule Engine integration")

if __name__ == "__main__":
    test_lot_calculator_compatibility()